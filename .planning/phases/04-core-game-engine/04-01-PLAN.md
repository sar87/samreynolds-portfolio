---
phase: 04-core-game-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/core/GameLoop.ts
  - src/game/core/Input.ts
  - src/game/core/Camera.ts
autonomous: true

must_haves:
  truths:
    - "Game loop runs continuously at stable framerate"
    - "Keyboard input state is tracked for movement keys"
    - "Camera can follow a target position smoothly"
  artifacts:
    - path: "src/game/core/GameLoop.ts"
      provides: "requestAnimationFrame loop with delta time"
      exports: ["GameLoop"]
      min_lines: 40
    - path: "src/game/core/Input.ts"
      provides: "Keyboard state tracking"
      exports: ["Input"]
      min_lines: 30
    - path: "src/game/core/Camera.ts"
      provides: "Viewport transform and lerp follow"
      exports: ["Camera"]
      min_lines: 50
  key_links:
    - from: "src/game/core/GameLoop.ts"
      to: "requestAnimationFrame"
      via: "browser API"
      pattern: "requestAnimationFrame"
    - from: "src/game/core/Input.ts"
      to: "window"
      via: "keydown/keyup listeners"
      pattern: "addEventListener.*key"
    - from: "src/game/core/Camera.ts"
      to: "lerp calculation"
      via: "exponential smoothing"
      pattern: "Math\\.exp"
---

<objective>
Create the three foundational core systems for the game engine: GameLoop (fixed timestep with delta time), Input (keyboard state tracking), and Camera (lerp follow with edge clamping).

Purpose: These are the fundamental building blocks that all other game systems depend on. They must be framerate-independent and handle edge cases correctly.

Output: Three TypeScript modules in src/game/core/ that can be instantiated and tested independently.
</objective>

<execution_context>
@/home/sam/.claude/get-shit-done/workflows/execute-plan.md
@/home/sam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-game-engine/04-CONTEXT.md
@.planning/phases/04-core-game-engine/04-RESEARCH.md
@src/config/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameLoop with delta time</name>
  <files>src/game/core/GameLoop.ts</files>
  <action>
Create a GameLoop class using requestAnimationFrame with framerate-independent delta time.

Requirements from RESEARCH.md:
- Use requestAnimationFrame (not setInterval)
- Calculate delta time in seconds (divide ms by 1000)
- Clamp delta to max 0.1s to prevent "spiral of death" on tab switch
- Provide start(), stop(), isRunning() methods
- Accept update(dt: number) and render() callbacks in constructor

Implementation pattern:
```typescript
export class GameLoop {
  private lastTime = 0;
  private running = false;
  private animationFrameId = 0;

  constructor(
    private onUpdate: (deltaTime: number) => void,
    private onRender: () => void
  ) {}

  start() { ... }
  stop() { ... }
  isRunning(): boolean { ... }
  private loop(currentTime: number) { ... }
}
```

Critical: Delta time must be clamped to prevent large jumps after tab becomes visible again.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
GameLoop class exists with start/stop/loop methods, delta time calculated in seconds, clamped to max 0.1s.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Input system for keyboard state</name>
  <files>src/game/core/Input.ts</files>
  <action>
Create an Input class that tracks keyboard state for movement keys.

Requirements from RESEARCH.md and CONTEXT.md:
- Track key state via keydown/keyup events (not event-based movement)
- Use event.code (not event.key) for layout independence (AZERTY, QWERTZ support)
- Support WASD and arrow keys (both map to same directions)
- Prevent default on arrow keys to stop page scrolling
- 4-directional only (context decision: no diagonal movement)
- Provide getMovementDirection() returning { x: -1|0|1, y: -1|0|1 }
- Provide isAnyMovementKeyPressed() for snap-to-grid logic
- Provide destroy() method to remove listeners

Implementation pattern:
```typescript
export class Input {
  private keys = new Map<string, boolean>();
  private keydownHandler: (e: KeyboardEvent) => void;
  private keyupHandler: (e: KeyboardEvent) => void;

  constructor() { ... }
  isKeyPressed(code: string): boolean { ... }
  getMovementDirection(): { x: number; y: number } { ... }
  isAnyMovementKeyPressed(): boolean { ... }
  destroy(): void { ... }
}
```

Movement keys to track: KeyW, KeyA, KeyS, KeyD, ArrowUp, ArrowDown, ArrowLeft, ArrowRight

For 4-directional (no diagonal): If both x and y directions pressed, prioritize vertical (y) or use last-pressed logic. Simplest: return early on first direction found.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Input class tracks WASD + arrows, uses event.code, prevents arrow key scrolling, provides direction and destroy methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Camera with lerp follow and clamping</name>
  <files>src/game/core/Camera.ts</files>
  <action>
Create a Camera class that smoothly follows a target and clamps to map boundaries.

Requirements from CONTEXT.md and RESEARCH.md:
- Smooth lerp follow with ~0.2s catch-up time (lerp speed ~10-15)
- Use framerate-independent lerp: 1 - Math.exp(-lerpSpeed * deltaTime)
- Clamp to map edges so no void is visible
- Fixed 2x scale (from EngineConfig)
- Provide follow(targetX, targetY, deltaTime) method
- Provide worldToScreen(worldX, worldY) for coordinate conversion
- Store x, y position (top-left corner of viewport)

Constructor parameters:
- viewportWidth, viewportHeight (in pixels, at render scale)
- mapWidth, mapHeight (in pixels, at render scale)

Implementation pattern:
```typescript
export class Camera {
  x = 0;
  y = 0;

  constructor(
    private viewportWidth: number,
    private viewportHeight: number,
    private mapWidth: number,
    private mapHeight: number
  ) {}

  follow(targetX: number, targetY: number, deltaTime: number): void { ... }
  worldToScreen(worldX: number, worldY: number): { x: number; y: number } { ... }
  setMapBounds(mapWidth: number, mapHeight: number): void { ... }
}
```

Lerp formula: `this.x += (targetCamX - this.x) * (1 - Math.exp(-lerpSpeed * deltaTime))`

Where targetCamX centers the camera on the target.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Camera class with lerp follow (~0.2s catch-up), edge clamping, and worldToScreen conversion.
  </done>
</task>

</tasks>

<verification>
All three core modules compile and export their classes:
```bash
npx tsc --noEmit
```

Files exist with expected exports:
- src/game/core/GameLoop.ts exports GameLoop class
- src/game/core/Input.ts exports Input class
- src/game/core/Camera.ts exports Camera class
</verification>

<success_criteria>
1. GameLoop runs via requestAnimationFrame with delta time in seconds
2. Input tracks WASD and arrow keys using event.code
3. Camera follows target with smooth lerp and clamps to bounds
4. All modules compile without TypeScript errors
5. No external dependencies added (browser APIs only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-game-engine/04-01-SUMMARY.md`
</output>
