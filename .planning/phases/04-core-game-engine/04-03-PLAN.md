---
phase: 04-core-game-engine
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/game/entities/Player.ts
  - src/game/rendering/Renderer.ts
autonomous: true

must_haves:
  truths:
    - "Player moves smoothly in 4 directions with keyboard input"
    - "Player snaps to tile grid when movement keys released"
    - "Player cannot walk through solid tiles"
    - "Tiles render only when visible in viewport"
  artifacts:
    - path: "src/game/entities/Player.ts"
      provides: "Player position, movement, collision integration"
      exports: ["Player"]
      min_lines: 80
    - path: "src/game/rendering/Renderer.ts"
      provides: "Canvas rendering with viewport culling"
      exports: ["Renderer"]
      min_lines: 70
  key_links:
    - from: "src/game/entities/Player.ts"
      to: "src/game/core/Input.ts"
      via: "getMovementDirection"
      pattern: "input\\.getMovementDirection"
    - from: "src/game/entities/Player.ts"
      to: "src/game/systems/Collision.ts"
      via: "moveWithCollision"
      pattern: "collision\\.moveWithCollision"
    - from: "src/game/rendering/Renderer.ts"
      to: "src/game/core/Camera.ts"
      via: "worldToScreen"
      pattern: "camera\\.worldToScreen"
    - from: "src/game/rendering/Renderer.ts"
      to: "src/game/rendering/TileMap.ts"
      via: "getTile iteration"
      pattern: "tileMap\\.getTile"
---

<objective>
Create the Player entity with hybrid movement and collision, and the Renderer with viewport culling for efficient tile rendering.

Purpose: The Player integrates input, collision, and the context-specified hybrid movement (smooth while keys held, snap on release). The Renderer handles all canvas drawing with viewport culling for performance.

Output: Player class that responds to input and obeys collision, Renderer class that draws visible tiles and the player.
</objective>

<execution_context>
@/home/sam/.claude/get-shit-done/workflows/execute-plan.md
@/home/sam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-game-engine/04-CONTEXT.md
@.planning/phases/04-core-game-engine/04-RESEARCH.md
@.planning/phases/04-core-game-engine/04-01-SUMMARY.md
@.planning/phases/04-core-game-engine/04-02-SUMMARY.md
@src/config/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Player entity with hybrid movement</name>
  <files>src/game/entities/Player.ts</files>
  <action>
Create a Player class implementing the context-specified hybrid movement system.

Requirements from CONTEXT.md:
- Smooth sub-tile movement while keys held
- 4-directional only (no diagonal)
- ~4 tiles/second speed (128 pixels/second at 32px base tiles)
- Snap to nearest tile center when keys released
- Hard stop on collision

Implementation:
```typescript
import { Input } from '../core/Input';
import { Collision } from '../systems/Collision';
import { EngineConfig } from '../../config/engine';

export class Player {
  x: number;  // Pixel position (at render scale)
  y: number;
  private readonly speed = 256; // 4 tiles/second at 64px rendered tiles
  private readonly snapSpeed = 10; // Lerp factor for grid snapping

  constructor(
    private input: Input,
    private collision: Collision,
    startTileX: number,
    startTileY: number
  ) {
    const tileSize = EngineConfig.renderedTileSize;
    this.x = startTileX * tileSize;
    this.y = startTileY * tileSize;
  }

  update(deltaTime: number): void {
    const tileSize = EngineConfig.renderedTileSize;
    const dir = this.input.getMovementDirection();

    if (dir.x !== 0 || dir.y !== 0) {
      // Keys held: smooth movement in one direction only (4-directional)
      // Prioritize last direction or vertical if both pressed
      let deltaX = 0;
      let deltaY = 0;

      if (dir.y !== 0) {
        deltaY = dir.y * this.speed * deltaTime;
      } else if (dir.x !== 0) {
        deltaX = dir.x * this.speed * deltaTime;
      }

      // Apply movement with collision
      const result = this.collision.moveWithCollision(
        this.x, this.y,
        deltaX, deltaY,
        tileSize, tileSize
      );
      this.x = result.x;
      this.y = result.y;
    } else {
      // Keys released: snap to nearest tile center
      const targetX = Math.round(this.x / tileSize) * tileSize;
      const targetY = Math.round(this.y / tileSize) * tileSize;

      const lerpFactor = 1 - Math.exp(-this.snapSpeed * deltaTime);
      this.x += (targetX - this.x) * lerpFactor;
      this.y += (targetY - this.y) * lerpFactor;

      // Snap when very close (avoid infinite lerp)
      if (Math.abs(this.x - targetX) < 0.5) this.x = targetX;
      if (Math.abs(this.y - targetY) < 0.5) this.y = targetY;
    }
  }

  // Get center position for camera following
  getCenterX(): number {
    return this.x + EngineConfig.renderedTileSize / 2;
  }

  getCenterY(): number {
    return this.y + EngineConfig.renderedTileSize / 2;
  }
}
```

Player hitbox is full tile size (32x32 at 1x = 64x64 at 2x scale). Context decision: simpler and more forgiving.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Player class with hybrid movement (smooth while held, snap on release), 4-directional, collision-aware, centered position getters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Renderer with viewport culling</name>
  <files>src/game/rendering/Renderer.ts</files>
  <action>
Create a Renderer class that draws tiles and player with viewport culling.

Requirements from RESEARCH.md:
- Only render tiles visible in viewport (massive performance gain)
- Use Math.floor on all coordinates (avoid sub-pixel blur)
- Disable alpha channel for opaque game (10-30% faster)
- Handle canvas resize (fill browser window)
- Use different colors for tile types (simple visualization for Phase 4)

Implementation:
```typescript
import { Camera } from '../core/Camera';
import { TileMap, TileType } from './TileMap';
import { Player } from '../entities/Player';
import { EngineConfig } from '../../config/engine';

// Simple color mapping for Phase 4 (sprites added in Phase 5)
const TILE_COLORS: Record<TileType, string> = {
  [TileType.EMPTY]: '#000000',
  [TileType.GRASS]: '#4a7c23',
  [TileType.WALL]: '#555555',
  [TileType.WATER]: '#3366aa',
  [TileType.PATH]: '#c4a35a',
};

export class Renderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  constructor(container: HTMLElement) {
    this.canvas = document.createElement('canvas');
    // CRITICAL: Disable alpha channel for opaque game (performance)
    this.ctx = this.canvas.getContext('2d', { alpha: false })!;
    container.appendChild(this.canvas);
    this.resize();
    window.addEventListener('resize', () => this.resize());
  }

  private resize(): void {
    // Fill browser window
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.canvas.style.display = 'block';
  }

  getWidth(): number {
    return this.canvas.width;
  }

  getHeight(): number {
    return this.canvas.height;
  }

  renderTiles(tileMap: TileMap, camera: Camera): void {
    const tileSize = EngineConfig.renderedTileSize;

    // Calculate visible tile range (viewport culling)
    const startCol = Math.floor(camera.x / tileSize);
    const endCol = Math.ceil((camera.x + this.canvas.width) / tileSize);
    const startRow = Math.floor(camera.y / tileSize);
    const endRow = Math.ceil((camera.y + this.canvas.height) / tileSize);

    // Render only visible tiles
    for (let row = startRow; row <= endRow; row++) {
      for (let col = startCol; col <= endCol; col++) {
        const tileType = tileMap.getTile(col, row);
        const color = TILE_COLORS[tileType] || TILE_COLORS[TileType.EMPTY];

        const screenPos = camera.worldToScreen(col * tileSize, row * tileSize);

        // CRITICAL: Use Math.floor for integer coordinates
        this.ctx.fillStyle = color;
        this.ctx.fillRect(
          Math.floor(screenPos.x),
          Math.floor(screenPos.y),
          tileSize,
          tileSize
        );
      }
    }
  }

  renderPlayer(player: Player, camera: Camera): void {
    const tileSize = EngineConfig.renderedTileSize;
    const screenPos = camera.worldToScreen(player.x, player.y);

    // Simple colored square for Phase 4 (sprite added in Phase 5)
    this.ctx.fillStyle = '#ff6600';
    this.ctx.fillRect(
      Math.floor(screenPos.x),
      Math.floor(screenPos.y),
      tileSize,
      tileSize
    );
  }

  clear(): void {
    // Use fillRect (faster than clearRect when redrawing everything)
    this.ctx.fillStyle = '#000000';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }

  destroy(): void {
    window.removeEventListener('resize', this.resize);
    this.canvas.remove();
  }
}
```

Simple colored rectangles for Phase 4. LPC sprite rendering added in Phase 5 (Campus & Buildings).
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Renderer class with viewport culling, integer coordinates, alpha disabled, colored tile rectangles, and player square.
  </done>
</task>

</tasks>

<verification>
All modules compile and integrate with prior plans:
```bash
npx tsc --noEmit
```

Files exist with expected exports:
- src/game/entities/Player.ts exports Player class
- src/game/rendering/Renderer.ts exports Renderer class

Integration points verified:
- Player imports Input, Collision, EngineConfig
- Renderer imports Camera, TileMap, Player, EngineConfig
</verification>

<success_criteria>
1. Player moves smoothly at ~4 tiles/second when keys held
2. Player snaps to grid when keys released (visible lerp)
3. Player cannot walk through solid tiles (collision works)
4. Renderer only draws tiles in viewport (culling implemented)
5. All coordinates use Math.floor (no sub-pixel blur)
6. All modules compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-game-engine/04-03-SUMMARY.md`
</output>
