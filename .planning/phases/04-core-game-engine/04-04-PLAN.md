---
phase: 04-core-game-engine
plan: 04
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - src/game/Game.ts
  - src/main.ts
  - src/styles/game.css
autonomous: false

must_haves:
  truths:
    - "Player can move around test map with arrow keys and WASD"
    - "Camera smoothly follows player"
    - "Collision prevents walking through walls"
    - "Game runs at 30+ FPS"
  artifacts:
    - path: "src/game/Game.ts"
      provides: "Main game coordinator"
      exports: ["Game"]
      min_lines: 80
    - path: "src/styles/game.css"
      provides: "Game canvas styling"
      min_lines: 10
  key_links:
    - from: "src/game/Game.ts"
      to: "src/game/core/GameLoop.ts"
      via: "loop callbacks"
      pattern: "GameLoop"
    - from: "src/game/Game.ts"
      to: "src/game/entities/Player.ts"
      via: "update call"
      pattern: "player\\.update"
    - from: "src/main.ts"
      to: "src/game/Game.ts"
      via: "game mode routing"
      pattern: "Game"
---

<objective>
Create the main Game coordinator that wires all systems together, integrate with the existing router/main.ts, and perform human verification of the complete game engine.

Purpose: This plan brings all components together into a working game mode. The Game class coordinates loop, input, camera, map, collision, player, and renderer. Integration with main.ts enables mode switching.

Output: Working game mode accessible via the existing mode toggle, with human verification that all Phase 4 success criteria are met.
</objective>

<execution_context>
@/home/sam/.claude/get-shit-done/workflows/execute-plan.md
@/home/sam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-game-engine/04-CONTEXT.md
@.planning/phases/04-core-game-engine/04-RESEARCH.md
@.planning/phases/04-core-game-engine/04-01-SUMMARY.md
@.planning/phases/04-core-game-engine/04-02-SUMMARY.md
@.planning/phases/04-core-game-engine/04-03-SUMMARY.md
@src/main.ts
@src/config/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Game coordinator class</name>
  <files>src/game/Game.ts, src/styles/game.css</files>
  <action>
Create the main Game class that coordinates all game systems.

Requirements:
- Initialize all systems in correct order
- Wire GameLoop callbacks to update/render
- Update camera to follow player each frame
- Provide start(), stop(), destroy() methods
- Optional: Add debug overlay showing FPS and player tile coordinates

Implementation:
```typescript
import { GameLoop } from './core/GameLoop';
import { Input } from './core/Input';
import { Camera } from './core/Camera';
import { TileMap } from './rendering/TileMap';
import { Collision } from './systems/Collision';
import { Player } from './entities/Player';
import { Renderer } from './rendering/Renderer';
import { testMapData } from './data/testMap';

export class Game {
  private gameLoop: GameLoop;
  private input: Input;
  private camera: Camera;
  private tileMap: TileMap;
  private collision: Collision;
  private player: Player;
  private renderer: Renderer;
  private debugEnabled = true; // Toggle for dev
  private frameCount = 0;
  private fpsDisplay = 0;
  private lastFpsUpdate = 0;

  constructor(container: HTMLElement) {
    // Initialize systems
    this.input = new Input();

    this.tileMap = new TileMap(
      testMapData.width,
      testMapData.height,
      testMapData.tiles
    );

    this.collision = new Collision(this.tileMap);

    this.player = new Player(
      this.input,
      this.collision,
      testMapData.playerSpawn.x,
      testMapData.playerSpawn.y
    );

    this.renderer = new Renderer(container);

    this.camera = new Camera(
      this.renderer.getWidth(),
      this.renderer.getHeight(),
      this.tileMap.getPixelWidth(),
      this.tileMap.getPixelHeight()
    );

    this.gameLoop = new GameLoop(
      (dt) => this.update(dt),
      () => this.render()
    );
  }

  private update(deltaTime: number): void {
    this.player.update(deltaTime);
    this.camera.follow(
      this.player.getCenterX(),
      this.player.getCenterY(),
      deltaTime
    );

    // FPS counter
    if (this.debugEnabled) {
      this.frameCount++;
      const now = performance.now();
      if (now - this.lastFpsUpdate >= 1000) {
        this.fpsDisplay = this.frameCount;
        this.frameCount = 0;
        this.lastFpsUpdate = now;
      }
    }
  }

  private render(): void {
    this.renderer.clear();
    this.renderer.renderTiles(this.tileMap, this.camera);
    this.renderer.renderPlayer(this.player, this.camera);

    // Debug overlay
    if (this.debugEnabled) {
      this.renderDebug();
    }
  }

  private renderDebug(): void {
    const tileSize = EngineConfig.renderedTileSize;
    const tileX = Math.floor(this.player.x / tileSize);
    const tileY = Math.floor(this.player.y / tileSize);

    // Draw debug text (simple implementation)
    const ctx = (this.renderer as any).ctx; // Access for debug only
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px monospace';
    ctx.fillText(`FPS: ${this.fpsDisplay}`, 10, 24);
    ctx.fillText(`Tile: ${tileX}, ${tileY}`, 10, 44);
  }

  start(): void {
    this.gameLoop.start();
  }

  stop(): void {
    this.gameLoop.stop();
  }

  destroy(): void {
    this.gameLoop.stop();
    this.input.destroy();
    this.renderer.destroy();
  }
}
```

Also create minimal game.css:
```css
/* Game mode canvas container */
#game-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #000;
  z-index: 1000;
}

#game-container canvas {
  display: block;
}
```

Import EngineConfig at top of Game.ts for debug display.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Game class coordinates all systems, runs loop, updates camera, provides start/stop/destroy, shows FPS overlay.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate game mode with main router</name>
  <files>src/main.ts</files>
  <action>
Update main.ts to support game mode alongside website mode.

Requirements:
- Add game route (e.g., #/game or via mode toggle)
- Create game container div when entering game mode
- Initialize and start Game when entering
- Destroy Game when leaving game mode
- Preserve existing website routing

Implementation approach:
```typescript
import { Game } from './game/Game';
import './styles/game.css';

let game: Game | null = null;

// Add game mode functions
function enterGameMode(): void {
  // Hide website content
  const content = document.getElementById('content');
  if (content) content.style.display = 'none';

  // Create game container
  let container = document.getElementById('game-container');
  if (!container) {
    container = document.createElement('div');
    container.id = 'game-container';
    document.body.appendChild(container);
  }

  // Start game
  game = new Game(container);
  game.start();
}

function exitGameMode(): void {
  if (game) {
    game.destroy();
    game = null;
  }

  // Remove game container
  const container = document.getElementById('game-container');
  if (container) container.remove();

  // Show website content
  const content = document.getElementById('content');
  if (content) content.style.display = '';
}

// Add route for game mode
router.add('/game', async () => {
  enterGameMode();
});
```

Also add a simple "Play Game" link somewhere on the home page (or restore the mode toggle from Phase 1). Could add to header nav or as a floating button.

For Phase 4, a simple nav link is sufficient:
- Add to Header.ts: `<a href="#/game" class="nav-link">Play Game</a>`
- Or add keyboard shortcut: Press 'G' to toggle game mode

Choose keyboard shortcut for simplicity - add event listener in main.ts:
```typescript
document.addEventListener('keydown', (e) => {
  if (e.key === 'g' || e.key === 'G') {
    if (game) {
      exitGameMode();
      router.navigate('/');
    } else {
      router.navigate('/game');
    }
  }
});
```
  </action>
  <verify>
`npm run dev` starts server, navigate to #/game shows game canvas, press G toggles mode
  </verify>
  <done>
Game mode accessible via #/game route and G key shortcut, properly initializes/destroys game instance.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 4 game engine: player movement, camera following, collision detection, and stable framerate.
  </what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Open browser to localhost URL
3. Press 'G' or navigate to #/game to enter game mode
4. Verify these Phase 4 success criteria:

**SC1: Player moves with arrow keys and WASD**
- [ ] Arrow keys move player (up/down/left/right)
- [ ] WASD keys move player (W/A/S/D)
- [ ] Movement is 4-directional only (no diagonal)
- [ ] Movement speed feels moderate (~4 tiles/second)

**SC2: Camera smoothly follows player**
- [ ] Camera follows as player moves
- [ ] Camera has slight smoothing (not instant snap)
- [ ] Camera stops at map edges (no black void visible)

**SC3: Collision prevents walking through obstacles**
- [ ] Player cannot walk through gray walls
- [ ] Player cannot walk into blue water
- [ ] Player can walk on green grass and tan paths

**SC4: Rendering at correct scale**
- [ ] Tiles are 64px (32x32 at 2x scale)
- [ ] Player is same size as tiles
- [ ] No visual blur or scaling artifacts

**SC5: Stable framerate**
- [ ] FPS counter shows 30+ FPS
- [ ] Movement feels smooth, no stuttering
- [ ] Tab switching doesn't break game (check after alt-tab)

**Additional checks:**
- [ ] Press 'G' to exit game mode and return to website
- [ ] Website still works after exiting game
- [ ] No console errors

Report any issues found.
  </how-to-verify>
  <resume-signal>Type "approved" if all criteria pass, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Phase 4 complete when human verifies all success criteria:
1. Player movement with WASD and arrow keys
2. Smooth camera following with edge clamping
3. Collision detection working (walls and water block movement)
4. 32x32 tiles rendering at 2x scale (64px)
5. 30+ FPS stable framerate
</verification>

<success_criteria>
All five Phase 4 success criteria verified by human testing:
1. Arrow keys and WASD move player
2. Camera smoothly follows player
3. Collision prevents walking through walls/water
4. Tiles render at consistent 64px scale
5. Game loop runs at 30+ FPS
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-game-engine/04-04-SUMMARY.md`
</output>
