---
phase: 03-website-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/styles/variables.css
  - src/styles/global.css
  - src/styles/utilities.css
  - src/types/content.ts
  - src/lib/content.ts
  - src/lib/router.ts
autonomous: true

must_haves:
  truths:
    - "Design tokens are available as CSS custom properties"
    - "Content data can be loaded and typed in TypeScript"
    - "Routes can be registered and navigated via hash"
  artifacts:
    - path: "src/styles/variables.css"
      provides: "CSS custom properties for colors, spacing, typography"
      contains: "--color-accent"
    - path: "src/styles/global.css"
      provides: "Reset, typography, base styles"
      contains: "InterVariable"
    - path: "src/types/content.ts"
      provides: "TypeScript interfaces for all content types"
      exports: ["Publication", "Talk", "Media", "Research", "About"]
    - path: "src/lib/content.ts"
      provides: "Content loading functions"
      exports: ["loadPublications", "loadTalks", "loadMedia", "loadResearch", "loadAbout"]
    - path: "src/lib/router.ts"
      provides: "Hash-based router"
      exports: ["router"]
  key_links:
    - from: "src/lib/content.ts"
      to: "data/*.json"
      via: "fetch"
      pattern: "fetch.*data/"
---

<objective>
Establish the foundational layer for the website mode: design system with CSS custom properties, TypeScript types and content loading utilities, and a simple hash-based router.

Purpose: These three independent foundations enable all subsequent UI work. The design system provides consistent styling, types ensure type-safe content handling, and the router enables navigation between pages.

Output: Design tokens in CSS, TypeScript interfaces for content, content loader functions, and a functional hash router.
</objective>

<execution_context>
@/home/sam/.claude/get-shit-done/workflows/execute-plan.md
@/home/sam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-website-mode/03-CONTEXT.md
@.planning/phases/03-website-mode/03-RESEARCH.md

# Content schemas for type definitions
@data/schemas/publication.schema.json
@data/schemas/talk.schema.json
@data/schemas/media.schema.json
@data/schemas/research.schema.json
@data/schemas/about.schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSS Design System</name>
  <files>
    src/styles/variables.css
    src/styles/global.css
    src/styles/utilities.css
  </files>
  <action>
Create three CSS files establishing the design system from RESEARCH.md:

**src/styles/variables.css:**
- Monochrome palette (gray-50 through gray-900, white, black)
- Accent colors: teal-500, teal-600, teal-700 (--color-accent: #0d9488)
- Semantic colors: bg, bg-secondary, text-primary/secondary/tertiary, border, link
- Typography scale: xs through 4xl (rem-based)
- Spacing scale: space-1 through space-20
- Layout tokens: --max-width: 1200px, --content-padding, --section-gap, --card-gap
- Transitions: --transition-fast (150ms), --transition-normal (250ms)
- Border radius: sm, md, lg

**src/styles/global.css:**
- Modern CSS reset (box-sizing, margin removal)
- Import Inter font from rsms.me/inter (use preconnect in HTML)
- Set font-family with InterVariable fallback pattern from research
- Enable font-feature-settings: 'liga' 1, 'calt' 1
- Base typography: line-height 1.6, text-rendering optimizeLegibility
- Smooth scroll with prefers-reduced-motion respect
- Container class with max-width and auto margins
- Mobile padding adjustment via media query at 768px

**src/styles/utilities.css:**
- .sr-only class for screen reader only content
- .container class (if not in global)
- Line clamp utilities if needed

Reference the exact values from 03-RESEARCH.md Pattern 1 and Pattern 5.
  </action>
  <verify>
Create a test HTML file or check via browser dev tools that:
- CSS variables are defined on :root
- Inter font loads (check Network tab)
- Smooth scroll works (add test anchors)
  </verify>
  <done>
All CSS custom properties defined in variables.css, global styles applied, Inter font configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript Types and Content Loader</name>
  <files>
    src/types/content.ts
    src/lib/content.ts
  </files>
  <action>
Create TypeScript types matching the JSON schemas:

**src/types/content.ts:**
```typescript
// Publication type
export interface Author {
  name: string;
  isSamReynolds: boolean;
}

export interface Publication {
  id: string;
  title: string;
  authors: Author[];
  journal: string;
  year: number;
  date: string;
  doi: string;
  abstract: string;
}

// Talk type
export interface Talk {
  id: string;
  title: string;
  venue: string;
  date: string;
  video?: string;
  slides?: string;
}

// Media type
export type MediaType = 'podcast' | 'video' | 'panel' | 'interview';

export interface MediaItem {
  id: string;
  type: MediaType;
  title: string;
  venue: string;
  date: string;
  link?: string;
  description: string;
}

// Research type
export interface ResearchTopic {
  id: string;
  name: string;
  description: string;
  relatedPublications: string[];
}

// About type
export interface Education {
  degree: string;
  institution: string;
  year: number;
}

export interface About {
  name: string;
  title: string;
  affiliation: string;
  email: string;
  bio: string[];
  education: Education[];
  links: {
    github: string;
    scholar: string;
    twitter: string;
    linkedin: string;
    researchgate: string;
  };
}
```

**src/lib/content.ts:**
Create async loader functions that fetch from data/*.json:
- loadPublications(): Promise<Publication[]>
- loadTalks(): Promise<Talk[]>
- loadMedia(): Promise<MediaItem[]>
- loadResearch(): Promise<ResearchTopic[]>
- loadAbout(): Promise<About>

Also create lookup functions:
- getPublicationById(id: string): Promise<Publication | undefined>
- getTalkById(id: string): Promise<Talk | undefined>
- getMediaById(id: string): Promise<MediaItem | undefined>

Cache loaded data to avoid refetching. Use a simple module-level cache object.
  </action>
  <verify>
```bash
npx tsc --noEmit
```
TypeScript compilation succeeds with no errors.
  </verify>
  <done>
All content types exported, loader functions work and are type-safe.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Hash Router</name>
  <files>
    src/lib/router.ts
  </files>
  <action>
Implement a simple hash-based router following the pattern from RESEARCH.md Pattern 3:

```typescript
type RouteHandler = (params: Record<string, string>) => void;

interface Route {
  pattern: RegExp;
  handler: RouteHandler;
}

class Router {
  private routes: Route[] = [];
  private currentPath: string = '';

  add(pattern: string, handler: RouteHandler): void {
    // Convert /publication/:id to regex with named groups
    const regexPattern = pattern.replace(/:(\w+)/g, '(?<$1>[^/]+)');
    this.routes.push({
      pattern: new RegExp(`^${regexPattern}$`),
      handler,
    });
  }

  init(): void {
    window.addEventListener('hashchange', () => this.route());
    // Handle initial route
    this.route();
  }

  private route(): void {
    const hash = window.location.hash.slice(1) || '/';

    // Skip if same route
    if (hash === this.currentPath) return;
    this.currentPath = hash;

    for (const { pattern, handler } of this.routes) {
      const match = hash.match(pattern);
      if (match) {
        handler(match.groups || {});
        return;
      }
    }

    // 404 fallback - navigate to home
    this.navigate('/');
  }

  navigate(path: string): void {
    window.location.hash = path;
  }

  getCurrentPath(): string {
    return this.currentPath;
  }
}

export const router = new Router();
```

This router:
- Supports parameterized routes like /publication/:id
- Extracts params as named groups
- Handles hashchange events
- Provides navigate() method
- Falls back to home on unknown routes
  </action>
  <verify>
```bash
npx tsc --noEmit
```
TypeScript compilation succeeds. Manual test: add router to main.ts with a test route, verify hashchange triggers handler.
  </verify>
  <done>
Hash router works, routes can be registered with parameters, navigation triggers handlers.
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run dev` and check browser:
   - CSS variables visible in dev tools on :root
   - Inter font loads (check Network tab for rsms.me)
   - No console errors
3. Content loader test (in dev console):
   ```javascript
   import { loadPublications } from '/src/lib/content.ts'
   loadPublications().then(console.log)
   ```
   Should log array of 15 publications with correct types.
</verification>

<success_criteria>
- [ ] CSS custom properties defined for colors, spacing, typography
- [ ] Inter font configured with proper fallbacks
- [ ] Smooth scroll respects prefers-reduced-motion
- [ ] TypeScript types match JSON schema structure
- [ ] Content loader functions fetch and cache data
- [ ] Router handles parameterized routes
- [ ] All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-website-mode/03-01-SUMMARY.md`
</output>
